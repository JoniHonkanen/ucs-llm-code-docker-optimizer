from enum import Enum
from typing import List, TypedDict, Optional
from pydantic import BaseModel, Field, Extra, validator


# Define an Enum for the proceed field
class ProceedOption(str, Enum):
    CONTINUE = "continue"
    CANCEL = "cancel"
    NEW = "new"


# Schema for whole code project
class Purpose(BaseModel):
    user_summary: str = Field(
        description="A summarized statement of what the user wants to achieve."
    )
    problem_type: str = Field(
        description="The type of problem that is being solved, e.g., logistics optimization, resource allocation, etc."
    )
    optimization_focus: str = Field(
        description="A description of how the solution should be optimized, focusing on improving how effectively the problem is solved. The emphasis is on achieving better alignment with the problem's core objectives, enhancing solution quality, and refining the approach to meet the user's goals without prioritizing performance metrics such as runtime."
    )
    chatbot_response: str = Field(
        description="The chatbot's response to the user, explaining what is the problem, what will be done to solve the problem and why this approach is being taken."
    )
    next_steps: str = Field(
        description="A detailed, numbered list outlining the next actions the AI agents will take to solve and optimize the problem. This includes generating code to address the problem, executing the necessary steps, and iterating through improvements to refine the solution. It should also highlight specific focus areas such as generating algorithms, validating correctness, and ensuring the solution aligns with the stated goals."
    )


class Code(BaseModel):
    python_code: str = Field(
        description="Python code generated by the AI agents to solve the user's problem."
    )
    requirements: Optional[str] = Field(
        default="No requirements provided",  # Default value in case it's missing
        description="A list of requirements or dependencies needed to run the generated Python code, such as those used in a requirements.txt file.",
    )
    resources: Optional[str] = Field(
        default="No additional resources provided",  # Default value in case it's missing
        description="Any additional requirements or files, such as data sheets (Excel files) or other resources, that are not included in the main requirements list but are necessary for the program.",
    )


class DockerFiles(BaseModel):
    dockerfile: str = Field(
        description="The Dockerfile that defines the Docker environment for running the generated Python code."
    )
    compose_file: str = Field(
        description="The docker-compose.yaml file that specifies the services and configurations for the Docker environment."
    )


class OutputOfCode(BaseModel):
    answer: str = Field(
        description="The numerical answer, detailing the quantities or results of the calculation (e.g., how much material to cut)."
    )
    table: Optional[str] = Field(
        description="Optional table format answer, summarizing the results in a structured layout (e.g., materials used per order).",
        default=None,
    )
    answer_description: str = Field(
        description="A very detailed explanation or context for the numerical answer, providing additional insights or interpretations of the result."
    )
    improvement: str = Field(
        description="Suggestions for enhancing the solution or optimization process."
    )
    objective_value: Optional[float] = Field(
        description="The objective value achieved by the optimization algorithm (e.g., the minimized waste or cost).",
        default=None,
    )
    explanation: str = Field(
        description="A detailed step-by-step explanation of how the algorithm arrived at the final result, describing key decisions and constraints."
    )


class AgentState(TypedDict):
    userInput: str
    iterations: int
    promptFiles: List[str]
    messages: List[str]
    purpose: Purpose
    proceed: ProceedOption
    code: Code
    dockerFiles: DockerFiles
    docker_output: str
    result = OutputOfCode
    results: List[OutputOfCode]
